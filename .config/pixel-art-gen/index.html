<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Pixel Art Generator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f0f0f0;
    }

    .container {
      background-color: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    h1 {
      text-align: center;
      color: #333;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
      padding: 20px;
      background-color: #f8f8f8;
      border-radius: 8px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
    }

    label {
      font-weight: bold;
      margin-bottom: 5px;
      color: #555;
    }

    input[type="number"], 
    input[type="range"], 
    select {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    input[type="file"] {
      padding: 10px;
      border: 2px dashed #007bff;
      border-radius: 4px;
      background-color: #f0f8ff;
      cursor: pointer;
    }

    button {
      padding: 10px 20px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      margin: 5px;
    }

    button:hover {
      background-color: #0056b3;
    }

    .output-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }

    .output-section {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      background-color: #fafafa;
    }

    canvas {
      border: 2px solid #333;
      max-width: 100%;
      height: auto;
      display: block;
      margin: 0 auto;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    #asciiOutput {
      font-family: 'Courier New', monospace;
      font-size: 6px;
      line-height: 6px;
      white-space: pre;
      overflow-x: auto;
      background-color: #1e1e1e;
      color: #fff;
      padding: 10px;
      border-radius: 4px;
      max-height: 600px;
      overflow-y: auto;
    }

    #colorPalette {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 10px;
    }

    .color-swatch {
      width: 30px;
      height: 30px;
      border: 1px solid #333;
      cursor: pointer;
    }

    .range-value {
      display: inline-block;
      width: 50px;
      text-align: center;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Advanced Pixel Art Generator</h1>
    
    <div class="controls">
      <div class="control-group">
        <label for="imageInput">Upload Image:</label>
        <input type="file" id="imageInput" accept="image/*">
      </div>
      
      <div class="control-group">
        <label for="pixelSize">Pixel Size:</label>
        <input type="range" id="pixelSize" min="4" max="50" value="16">
        <span class="range-value" id="pixelSizeValue">16</span>
      </div>
      
      <div class="control-group">
        <label for="colorCount">Color Count:</label>
        <input type="range" id="colorCount" min="2" max="256" value="16">
        <span class="range-value" id="colorCountValue">16</span>
      </div>
      
      <div class="control-group">
        <label for="outputType">Output Type:</label>
        <select id="outputType">
          <option value="canvas">Canvas Only</option>
          <option value="both">Both</option>
          <option value="ascii">ASCII Only</option>
        </select>
      </div>
      
      <div class="control-group">
        <label for="asciiStyle">ASCII Style:</label>
        <select id="asciiStyle">
          <option value="blocks">Color Blocks</option>
          <option value="chars">Characters</option>
          <option value="ansi">ANSI Escape</option>
        </select>
      </div>
      
      <div class="control-group">
        <label for="showGrid">
          <input type="checkbox" id="showGrid"> Show Pixel Grid
        </label>
      </div>
    </div>
    
    <div style="text-align: center;">
      <button id="processBtn">Generate Pixel Art</button>
      <button id="downloadCanvas">Download Image</button>
      <button id="downloadAscii">Download ASCII</button>
      <button id="copyAnsi">Copy ANSI Code</button>
    </div>
    
    <div class="output-container">
      <div class="output-section">
        <h3>Pixel Art Canvas</h3>
        <canvas id="canvas" style="min-height: 200px; background: #f0f0f0;"></canvas>
        <p style="text-align: center; color: #666; font-size: 12px; margin-top: 10px;">
          Upload an image to start. Adjust pixel size to control the level of pixelation.
        </p>
        <div id="colorPalette"></div>
      </div>
      
      <div class="output-section">
        <h3>ASCII Art Output</h3>
        <div id="asciiOutput"><p style="color: #666; text-align: center;">Select "Both" or "ASCII Only" to generate ASCII art</p></div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const imageInput = document.getElementById('imageInput');
    const pixelSizeSlider = document.getElementById('pixelSize');
    const colorCountSlider = document.getElementById('colorCount');
    const processBtn = document.getElementById('processBtn');
    const asciiOutput = document.getElementById('asciiOutput');
    
    let uploadedImage = null;
    let currentPalette = [];
    let pixelData = [];
    
    // Initialize canvas with a message
    canvas.width = 400;
    canvas.height = 200;
    ctx.fillStyle = '#999';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Upload an image to create pixel art', canvas.width / 2, canvas.height / 2);
    
    // Update range values
    document.querySelectorAll('input[type="range"]').forEach(slider => {
      const valueDisplay = document.getElementById(slider.id + 'Value');
      slider.addEventListener('input', () => {
        valueDisplay.textContent = slider.value;
      });
      
      // Auto-update on change
      slider.addEventListener('change', () => {
        if (uploadedImage) processImage();
      });
    });
    
    imageInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          uploadedImage = img;
          // Auto-process with canvas output only
          document.getElementById('outputType').value = 'canvas';
          processImage();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    });
    
    processBtn.addEventListener('click', processImage);
    document.getElementById('showGrid').addEventListener('change', () => {
      if (uploadedImage) processImage();
    });
    
    document.getElementById('outputType').addEventListener('change', () => {
      if (uploadedImage) processImage();
    });
    
    function processImage() {
      if (!uploadedImage) return;
      
      const pixelSize = parseInt(pixelSizeSlider.value);
      const colorCount = parseInt(colorCountSlider.value);
      const outputType = document.getElementById('outputType').value;
      
      // Calculate pixelated dimensions
      const pixelWidth = Math.floor(uploadedImage.width / pixelSize);
      const pixelHeight = Math.floor(uploadedImage.height / pixelSize);
      
      // Limit maximum pixels to prevent performance issues
      const maxPixels = 200;
      if (pixelWidth > maxPixels || pixelHeight > maxPixels) {
        alert(`Image too large for this pixel size. Maximum ${maxPixels}x${maxPixels} pixels. Try increasing pixel size.`);
        return;
      }
      
      // Set canvas size to match original image
      canvas.width = pixelWidth * pixelSize;
      canvas.height = pixelHeight * pixelSize;
      
      // Create temporary canvas for sampling
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = uploadedImage.width;
      tempCanvas.height = uploadedImage.height;
      tempCtx.drawImage(uploadedImage, 0, 0);
      
      // Get pixel data by sampling
      const imageData = tempCtx.getImageData(0, 0, uploadedImage.width, uploadedImage.height);
      const data = imageData.data;
      
      // Sample colors from the original image
      const sampledColors = [];
      pixelData = [];
      
      for (let py = 0; py < pixelHeight; py++) {
        const row = [];
        for (let px = 0; px < pixelWidth; px++) {
          // Sample from center of each pixel block
          const x = Math.floor(px * pixelSize + pixelSize / 2);
          const y = Math.floor(py * pixelSize + pixelSize / 2);
          const idx = (y * uploadedImage.width + x) * 4;
          
          const color = [data[idx], data[idx + 1], data[idx + 2]];
          sampledColors.push(color);
          row.push(color);
        }
        pixelData.push(row);
      }
      
      // Quantize colors if needed
      if (colorCount < 256) {
        currentPalette = quantizeColors(sampledColors, colorCount);
        
        // Map each pixel to nearest palette color
        for (let y = 0; y < pixelData.length; y++) {
          for (let x = 0; x < pixelData[y].length; x++) {
            pixelData[y][x] = findNearestColor(pixelData[y][x], currentPalette);
          }
        }
      } else {
        // Use all colors
        currentPalette = [...new Set(sampledColors.map(c => JSON.stringify(c)))].map(c => JSON.parse(c));
      }
      
      // Draw pixelated image on canvas
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      for (let y = 0; y < pixelData.length; y++) {
        for (let x = 0; x < pixelData[y].length; x++) {
          const color = pixelData[y][x];
          ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
          ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
        }
      }
      
      // Draw grid if enabled
      if (document.getElementById('showGrid').checked) {
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.lineWidth = 1;
        
        // Draw vertical lines
        for (let x = 0; x <= pixelWidth; x++) {
          ctx.beginPath();
          ctx.moveTo(x * pixelSize, 0);
          ctx.lineTo(x * pixelSize, canvas.height);
          ctx.stroke();
        }
        
        // Draw horizontal lines
        for (let y = 0; y <= pixelHeight; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * pixelSize);
          ctx.lineTo(canvas.width, y * pixelSize);
          ctx.stroke();
        }
      }
      
      // Display palette
      if (outputType === 'both' || outputType === 'canvas') {
        displayColorPalette(currentPalette.slice(0, 32)); // Show max 32 colors
      }
      
      // Generate ASCII art only if requested
      if (outputType === 'both' || outputType === 'ascii') {
        generateASCIIArt(pixelData);
      } else {
        // Clear ASCII output if not needed
        asciiOutput.innerHTML = '<p style="color: #666; text-align: center;">Select "Both" or "ASCII Only" to generate ASCII art</p>';
      }
    }
    
    function quantizeColors(colors, k) {
      // Simple k-means clustering for color quantization
      if (colors.length <= k) return colors;
      
      // Initialize centroids randomly
      let centroids = [];
      for (let i = 0; i < k; i++) {
        centroids.push(colors[Math.floor(Math.random() * colors.length)]);
      }
      
      // K-means iterations
      for (let iter = 0; iter < 10; iter++) {
        // Assign colors to nearest centroid
        const clusters = Array(k).fill(null).map(() => []);
        
        colors.forEach(color => {
          let minDist = Infinity;
          let bestCluster = 0;
          
          centroids.forEach((centroid, idx) => {
            const dist = colorDistance(color, centroid);
            if (dist < minDist) {
              minDist = dist;
              bestCluster = idx;
            }
          });
          
          clusters[bestCluster].push(color);
        });
        
        // Update centroids
        centroids = clusters.map(cluster => {
          if (cluster.length === 0) return centroids[0];
          
          const sum = cluster.reduce((acc, color) => {
            return [acc[0] + color[0], acc[1] + color[1], acc[2] + color[2]];
          }, [0, 0, 0]);
          
          return [
            Math.round(sum[0] / cluster.length),
            Math.round(sum[1] / cluster.length),
            Math.round(sum[2] / cluster.length)
          ];
        });
      }
      
      return centroids;
    }
    
    function colorDistance(c1, c2) {
      return Math.sqrt(
        Math.pow(c1[0] - c2[0], 2) +
        Math.pow(c1[1] - c2[1], 2) +
        Math.pow(c1[2] - c2[2], 2)
      );
    }
    
    function findNearestColor(color, palette) {
      let minDist = Infinity;
      let nearest = palette[0];
      
      palette.forEach(paletteColor => {
        const dist = colorDistance(color, paletteColor);
        if (dist < minDist) {
          minDist = dist;
          nearest = paletteColor;
        }
      });
      
      return nearest;
    }
    
    function generateASCIIArt(pixelData) {
      const style = document.getElementById('asciiStyle').value;
      
      if (style === 'blocks') {
        generateColorBlocks(pixelData);
      } else if (style === 'chars') {
        generateCharacterArt(pixelData);
      } else if (style === 'ansi') {
        generateANSIArt(pixelData);
      }
    }
    
    function generateColorBlocks(pixelData) {
      let html = '';
      pixelData.forEach(row => {
        row.forEach(color => {
          const hex = rgbToHex(color[0], color[1], color[2]);
          html += `<span style="color: ${hex}">██</span>`;
        });
        html += '\n';
      });
      asciiOutput.innerHTML = html;
    }
    
    function generateCharacterArt(pixelData) {
      const chars = ' .:-=+*#%@';
      let text = '';
      
      pixelData.forEach(row => {
        row.forEach(color => {
          const brightness = (color[0] + color[1] + color[2]) / 3;
          const charIndex = Math.floor((brightness / 255) * (chars.length - 1));
          const hex = rgbToHex(color[0], color[1], color[2]);
          text += `<span style="color: ${hex}">${chars[charIndex]}</span>`;
        });
        text += '\n';
      });
      asciiOutput.innerHTML = text;
    }
    
    function generateANSIArt(pixelData) {
      let ansiCode = '';
      let powershellCode = '';
      
      pixelData.forEach((row, y) => {
        let ansiLine = '';
        let psLine = 'Write-Host "';
        
        row.forEach((color, x) => {
          // ANSI escape code format
          ansiLine += `\\e[38;2;${color[0]};${color[1]};${color[2]}m█`;
          
          // PowerShell format
          psLine += `\`e[38;2;${color[0]};${color[1]};${color[2]}m█`;
        });
        
        ansiLine += '\\e[0m\\n';
        psLine += '\`e[0m"';
        
        ansiCode += ansiLine;
        powershellCode += psLine + '\n';
      });
      
      // Display preview with actual colors
      let html = '';
      pixelData.forEach(row => {
        row.forEach(color => {
          const hex = rgbToHex(color[0], color[1], color[2]);
          html += `<span style="color: ${hex}">█</span>`;
        });
        html += '\n';
      });
      
      asciiOutput.innerHTML = html;
      
      // Store both ANSI and PowerShell versions
      asciiOutput.dataset.ansiCode = ansiCode;
      asciiOutput.dataset.powershellCode = powershellCode;
    }
    
    function displayColorPalette(palette) {
      const paletteDiv = document.getElementById('colorPalette');
      paletteDiv.innerHTML = '<h4>Color Palette:</h4>';
      
      palette.forEach(color => {
        const swatch = document.createElement('div');
        swatch.className = 'color-swatch';
        swatch.style.backgroundColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
        swatch.title = `RGB(${color[0]}, ${color[1]}, ${color[2]})`;
        paletteDiv.appendChild(swatch);
      });
    }
    
    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }
    
    // Download functions
    document.getElementById('downloadCanvas').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'pixel-art.png';
      link.href = canvas.toDataURL();
      link.click();
    });
    
    document.getElementById('downloadAscii').addEventListener('click', () => {
      const text = asciiOutput.innerText;
      const blob = new Blob([text], { type: 'text/plain' });
      const link = document.createElement('a');
      link.download = 'ascii-art.txt';
      link.href = URL.createObjectURL(blob);
      link.click();
    });
    
    document.getElementById('copyAnsi').addEventListener('click', () => {
      const ansiCode = asciiOutput.dataset.ansiCode;
      if (ansiCode) {
        navigator.clipboard.writeText(ansiCode);
        alert('ANSI code copied to clipboard!');
      }
    });
  </script>
</body>
</html>
